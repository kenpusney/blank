<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Tilemap Editor</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Apply Inter font family */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f3f4f6; /* Light gray background */
            display: flex; /* Use flexbox for body */
            height: 100vh; /* Full viewport height */
            overflow: hidden; /* Prevent body scroll */
        }
        /* Custom styles for canvas to ensure it fits and looks good */
        canvas {
            background-color: #000; /* Black background for visibility */
            border: 1px solid #ccc; /* Light border */
            display: block;
            margin: 0 auto; /* Center the canvas */
            cursor: crosshair; /* Indicate drawing mode */
            width: 100%; /* Canvas takes full width of its container */
            height: 100%; /* Canvas takes full height of its container */
        }
        /* Style for radio buttons to make them look like toggles */
        input[type="radio"]:checked + label {
            background-color: #3b82f6; /* Blue for selected tool */
            color: white;
            border-color: #2563eb;
        }

        /* Sidebar specific styles */
        #sidebar {
            width: 320px; /* Default width for sidebar */
            min-width: 320px; /* Prevent shrinking too much */
            max-width: 320px; /* Prevent growing too much */
            background-color: #ffffff;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease-in-out, min-width 0.3s ease-in-out, max-width 0.3s ease-in-out, transform 0.3s ease-in-out;
            overflow-y: auto; /* Allow scrolling within the sidebar if content overflows */
            flex-shrink: 0; /* Prevent sidebar from shrinking when main content needs space */
        }

        #sidebar.collapsed {
            width: 0;
            min-width: 0;
            max-width: 0;
            padding: 0;
            transform: translateX(-100%); /* Visually hide it */
            overflow: hidden; /* Hide content */
        }

        #sidebar-content {
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
            flex-grow: 1; /* Allow content to grow */
        }

        #sidebar.collapsed #sidebar-content {
            opacity: 0;
            pointer-events: none; /* Disable interactions when collapsed */
        }

        #toggleSidebarBtn {
            position: absolute; /* Position relative to the main layout, outside sidebar */
            top: 1rem;
            left: calc(320px + 1rem); /* Position right of the sidebar + some margin */
            z-index: 50; /* Above canvas */
            transition: left 0.3s ease-in-out;
            background-color: #3b82f6;
            color: white;
            border-radius: 9999px; /* Circle shape */
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #toggleSidebarBtn.collapsed {
            left: 1rem; /* Move to the left when sidebar is collapsed */
        }

        /* Main content area for canvas */
        #mainContent {
            flex-grow: 1; /* Takes all available space */
            display: flex;
            flex-direction: column;
            padding: 1rem;
            position: relative; /* For positioning rulers/indicators */
            overflow: hidden; /* Hide canvas overflow, handled by its container */
        }

        /* Container for canvas and rulers/indicators */
        .canvas-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            flex-grow: 1; /* Takes available vertical space */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            background-color: #000;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
            border-radius: 0.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            flex-grow: 1; /* Canvas container takes remaining space within wrapper */
        }

        .ruler-x, .ruler-y {
            position: absolute;
            font-family: monospace;
            font-size: 10px;
            color: #9ca3af;
            z-index: 10;
        }

        .ruler-x {
            top: 0;
            left: 0;
            width: 100%;
            height: 20px;
            display: flex;
            overflow: hidden;
            background-color: #333;
        }

        .ruler-y {
            top: 0;
            left: 0;
            width: 20px;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #333;
        }

        .ruler-x span, .ruler-y span {
            position: absolute;
            text-align: center;
            line-height: 20px;
            white-space: nowrap;
        }
        .ruler-y span {
            text-align: right;
            padding-right: 2px;
        }

        #coordinatesDisplay {
            min-height: 24px;
            text-align: center;
            font-family: monospace;
            font-size: 0.9rem;
            color: #4b5563;
            margin-top: 0.5rem;
        }

        /* Side Indicators Styling */
        .indicator {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            z-index: 20;
        }
        .indicator.visible {
            opacity: 1;
        }
        .indicator-top, .indicator-bottom {
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 20px;
        }
        .indicator-top { top: 0; border-bottom-left-radius: 0.5rem; border-bottom-right-radius: 0.5rem; }
        .indicator-bottom { bottom: 0; border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem; }
        .indicator-left, .indicator-right {
            top: 50%;
            transform: translateY(-50%);
            height: 80%;
            width: 20px;
        }
        .indicator-left { left: 0; border-top-right-radius: 0.5rem; border-bottom-right-radius: 0.5rem; }
        .indicator-right { right: 0; border-top-left-radius: 0.5rem; border-bottom-left-radius: 0.5rem; }
    </style>
</head>
<body>
    <!-- Sidebar Toggle Button -->
    <button id="toggleSidebarBtn">
        <span id="toggleIcon">◀</span>
    </button>

    <!-- Sidebar -->
    <div id="sidebar" class="bg-white p-4 shadow-lg flex flex-col transition-all duration-300 ease-in-out overflow-y-auto">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold text-gray-800">Controls</h2>
        </div>
        <div id="sidebar-content" class="space-y-6">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">ASCII Tilemap Editor</h1>

            <!-- Map Configuration -->
            <div class="bg-gray-50 p-4 rounded-lg shadow-inner flex flex-col items-center justify-center space-y-4">
                <div class="flex items-center space-x-2">
                    <label for="mapWidth" class="text-gray-700 font-medium">Width:</label>
                    <input type="number" id="mapWidth" value="40" min="20" max="65536"
                           class="w-24 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="mapHeight" class="text-gray-700 font-medium">Height:</label>
                    <input type="number" id="mapHeight" value="25" min="20" max="65536"
                           class="w-24 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="roomCount" id="roomCountLabel" class="text-gray-700 font-medium">Rooms:</label>
                    <input type="number" id="roomCount" value="5" min="2" max="65536"
                           class="w-24 px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="mapStyle" class="text-gray-700 font-medium">Style:</label>
                    <select id="mapStyle" class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="town">Town</option>
                        <option value="cave">Cave</option>
                        <option value="forest">Forest</option>
                    </select>
                </div>
                <button id="createMapBtn"
                        class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    Create Map
                </button>
                <button id="randomMapBtn"
                        class="px-5 py-2 bg-purple-600 text-white font-semibold rounded-md shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    Random Map
                </button>
            </div>

            <!-- Tool Selection and Character Input -->
            <div class="bg-gray-50 p-4 rounded-lg shadow-inner flex flex-col items-center justify-center space-y-4">
                <div class="flex flex-wrap gap-2 justify-center">
                    <input type="radio" id="toolPaint" name="tool" value="paint" checked class="hidden">
                    <label for="toolPaint" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Paint
                    </label>

                    <input type="radio" id="toolBox" name="tool" value="box" class="hidden">
                    <label for="toolBox" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Box
                    </label>

                    <input type="radio" id="toolFill" name="tool" value="fill" class="hidden">
                    <label for="toolFill" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Fill
                    </label>

                    <input type="radio" id="toolDoor" name="tool" value="door" class="hidden">
                    <label for="toolDoor" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Door
                    </label>

                    <input type="radio" id="toolStairs" name="tool" value="stairs" class="hidden">
                    <label for="toolStairs" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Stairs
                    </label>

                    <input type="radio" id="toolMove" name="tool" value="move" class="hidden">
                    <label for="toolMove" class="px-4 py-2 rounded-md border border-gray-300 text-gray-700 font-medium cursor-pointer hover:bg-blue-100 transition duration-150 ease-in-out">
                        Move
                    </label>
                </div>

                <div class="flex items-center space-x-2 mt-4 lg:mt-0">
                    <label for="drawCharInput" class="text-gray-700 font-medium">Custom Char:</label>
                    <input type="text" id="drawCharInput" value="#" maxlength="1"
                           class="w-16 px-3 py-2 text-center border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                </div>
            </div>


            <!-- Quick Characters Dropdowns -->
            <div class="bg-gray-50 p-4 rounded-lg shadow-inner flex flex-wrap gap-4 justify-center">
                <div class="flex items-center space-x-2">
                    <label for="charGroupBasic" class="text-gray-700 font-medium">Basic:</label>
                    <select id="charGroupBasic" name="quickCharGroup"
                            class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="#"># Wall</option>
                        <option value=".">. Floor</option>
                        <option value=" ">_ Empty</option>
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="charGroupEntryExit" class="text-gray-700 font-medium">Entry/Exit:</label>
                    <select id="charGroupEntryExit" name="quickCharGroup"
                            class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="+">+ Door</option>
                        <option value=">">> Stairs Down</option>
                        <option value="<">< Stairs Up</option>
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="charGroupCreatures" class="text-gray-700 font-medium">Creatures:</label>
                    <select id="charGroupCreatures" name="quickCharGroup"
                            class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="@">@ Player</option>
                        <option value="X">X Monster</option>
                        <option value="D">D Dragon</option>
                        <option value="S">S Snake</option>
                        <option value="G">G Goblin</option>
                        <option value="E">E Eye</option>
                        <option value="C">C Cyclops</option>
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="charGroupItems" class="text-gray-700 font-medium">Items/Objects:</label>
                    <select id="charGroupItems" name="quickCharGroup"
                            class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="~">~ Liquid</option>
                        <option value="$">$ Gold</option>
                        <option value="P">P Potion</option>
                        <option value="K">K Key</option>
                        <option value="F">F Food</option>
                        <option value="!">! Exclamation</option>
                        <option value="?">? Question</option>
                    </select>
                </div>

                <div class="flex items-center space-x-2">
                    <label for="charGroupNumbers" class="text-gray-700 font-medium">Numbers:</label>
                    <select id="charGroupNumbers" name="quickCharGroup"
                            class="px-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm text-gray-800">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                </div>
            </div>

            <!-- Zoom Controls & Action Buttons - Stacked Vertically -->
            <div class="flex flex-col items-center space-y-2 mt-6">
                <button id="zoomInBtn" class="w-full px-4 py-2 bg-gray-600 text-white font-semibold rounded-md shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition duration-150 ease-in-out">
                    Zoom In (+)
                </button>
                <button id="zoomOutBtn" class="w-full px-4 py-2 bg-gray-600 text-white font-semibold rounded-md shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 transition duration-150 ease-in-out">
                    Zoom Out (-)
                </button>
                <button id="clearMapBtn"
                        class="w-full px-5 py-2 bg-red-600 text-white font-semibold rounded-md shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    Clear Map
                </button>
                <button id="exportMapBtn"
                        class="w-full px-5 py-2 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    Export Map
                </button>
                <input type="file" id="loadFileInput" accept=".txt" class="hidden">
                <button id="loadMapBtn"
                        class="w-full px-5 py-2 bg-yellow-600 text-white font-semibold rounded-md shadow-md hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 transition duration-150 ease-in-out">
                    Load Map
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content Area (Canvas + Rulers) -->
    <div id="mainContent" class="flex flex-col flex-grow bg-gray-200">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">ASCII Tilemap Editor</h1>
        <div class="canvas-wrapper flex flex-col items-center">
            <div id="rulerX" class="ruler-x relative w-full h-[20px] rounded-t-lg bg-gray-700 overflow-hidden"></div>
            <div class="flex w-full flex-grow">
                <div id="rulerY" class="ruler-y relative w-[20px] h-full rounded-l-lg bg-gray-700 overflow-hidden"></div>
                <div class="canvas-container relative flex-grow">
                    <canvas id="tilemapCanvas"></canvas>
                    <!-- Side Indicators -->
                    <div id="indicatorTop" class="indicator indicator-top rounded-b-lg">▲</div>
                    <div id="indicatorBottom" class="indicator indicator-bottom rounded-t-lg">▼</div>
                    <div id="indicatorLeft" class="indicator indicator-left rounded-r-lg">◀</div>
                    <div id="indicatorRight" class="indicator indicator-right rounded-l-lg">▶</div>
                </div>
            </div>
            <div id="coordinatesDisplay" class="mt-2">Mouse: (X: -, Y: -)</div>
        </div>
    </div>

    <!-- Message Box for user feedback -->
    <div id="messageBox" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full text-center">
            <p id="messageText" class="text-gray-800 text-lg font-medium mb-4"></p>
            <button id="closeMessageBoxBtn" class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                OK
            </button>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('tilemapCanvas');
        const ctx = canvas.getContext('2d');
        const mapWidthInput = document.getElementById('mapWidth');
        const mapHeightInput = document.getElementById('mapHeight');
        const roomCountInput = document.getElementById('roomCount');
        const roomCountLabel = document.getElementById('roomCountLabel');
        const mapStyleSelect = document.getElementById('mapStyle');
        const createMapBtn = document.getElementById('createMapBtn');
        const randomMapBtn = document.getElementById('randomMapBtn');
        const toolRadios = document.querySelectorAll('input[name="tool"]');
        const drawCharInput = document.getElementById('drawCharInput');
        const quickCharGroupSelects = document.querySelectorAll('select[name="quickCharGroup"]');
        const clearMapBtn = document.getElementById('clearMapBtn');
        const exportMapBtn = document.getElementById('exportMapBtn');
        const loadFileInput = document.getElementById('loadFileInput');
        const loadMapBtn = document.getElementById('loadMapBtn');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessageBoxBtn = document.getElementById('closeMessageBoxBtn');
        const coordinatesDisplay = document.getElementById('coordinatesDisplay');
        const rulerX = document.getElementById('rulerX');
        const rulerY = document.getElementById('rulerY');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        const indicatorTop = document.getElementById('indicatorTop');
        const indicatorBottom = document.getElementById('indicatorBottom');
        const indicatorLeft = document.getElementById('indicatorLeft');
        const indicatorRight = document.getElementById('indicatorRight');

        const sidebar = document.getElementById('sidebar');
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const toggleIcon = document.getElementById('toggleIcon');
        const mainContent = document.getElementById('mainContent');

        // --- Global Variables ---
        let mapData = []; // 2D array to store ASCII characters
        let mapWidth = parseInt(mapWidthInput.value);
        let mapHeight = parseInt(mapHeightInput.value);
        let charSize = 16; // Current drawing size of each character in pixels
        let baseCharSize = 16; // The calculated base character size to fit the map in initial view
        let currentZoom = 1.0; // Current zoom level
        const MIN_ZOOM = 0.1;
        const MAX_ZOOM = 5.0;
        const ZOOM_STEP = 0.1;
        const ZOOM_WHEEL_STEP = 0.05; // Smaller step for mouse wheel

        let currentCol = '#f0f0f0'; // Default text color for characters

        let currentTool = 'paint'; // Default tool
        let drawChar = drawCharInput.value; // Default drawing character

        let isDrawing = false; // Flag for drawing state (for paint, box)
        let isPanning = false; // Flag for panning state (for move tool)
        let startGridX = -1, startGridY = -1; // For box tool starting coordinates
        let lastPanMouseX = 0, lastPanMouseY = 0; // For move tool mouse tracking

        // Viewport offset for panning (in pixels relative to the full map)
        let viewOffsetX = 0;
        let viewOffsetY = 0;

        // Stores generated room objects for pathfinding (primarily for town)
        let generatedRooms = [];

        // Global visited matrix for region carving to ensure distinct regions
        let globalVisitedRegions = [];

        // Constants for region sizes (as percentage of total map area)
        const MIN_REGION_SIZE_FACTOR = 0.005; // 0.5% of total map area
        const MAX_REGION_SIZE_FACTOR = 0.05;  // 5% of total map area
        const MAX_CARVE_ATTEMPTS = 50; // Max attempts to place a region for each desired region

        // --- Helper Functions ---

        /**
         * Displays a message box to the user.
         * @param {string} message The message to display.
         */
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }

        /**
         * Validates map dimensions and room count against requirements.
         * @returns {boolean} True if dimensions are valid, false otherwise.
         */
        function validateMapParameters(width, height, rooms) {
            if (width < 20 || width > 65536 || height < 20 || height > 65536) {
                showMessageBox("Map dimensions (width/height) must be between 20 and 65536.");
                return false;
            }
            if (rooms < 2 || rooms > 65536) {
                showMessageBox("Number of rooms/caves/clearings must be between 2 and 65536.");
                return false;
            }
            // Add warning for extremely large maps, but don't prevent
            if (width * height > 25000000) { // 5000x5000 = 25,000,000 cells
                 showMessageBox("Warning: Extremely large maps may cause performance issues or browser crashes due to memory limitations. Proceed with caution.");
            }
            return true;
        }

        /**
         * Initializes the map data and resets view.
         * Fills the map with spaces (' ').
         */
        function initializeMap() {
            const newMapWidth = parseInt(mapWidthInput.value);
            const newMapHeight = parseInt(mapHeightInput.value);
            const newRoomCount = parseInt(roomCountInput.value); // Even if not used directly, validate

            if (!validateMapParameters(newMapWidth, newMapHeight, newRoomCount)) {
                // Revert inputs to current map size if validation fails
                mapWidthInput.value = mapWidth;
                mapHeightInput.value = mapHeight;
                roomCountInput.value = newRoomCount; // Keep last entered room count
                return;
            }

            mapWidth = newMapWidth;
            mapHeight = newMapHeight;

            mapData = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(' ')); // Fill with spaces
            generatedRooms = []; // Clear rooms on new map creation
            currentZoom = 1.0; // Reset zoom
            viewOffsetX = 0; // Reset pan
            viewOffsetY = 0; // Reset pan
            updateCanvasAndDraw();
        }

        /**
         * Updates canvas dimensions, calculates charSize, and redraws everything.
         * Call this after map size changes, window resize, or zoom changes.
         */
        function updateCanvasAndDraw() {
            // Get the actual client dimensions of the canvas container
            const canvasContainer = canvas.parentElement;
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            // Determine the base character size so the whole map fits at zoom 1.0 initially
            const maxCharSizeX = canvas.width / mapWidth;
            const maxCharSizeY = canvas.height / mapHeight;
            baseCharSize = Math.max(8, Math.min(maxCharSizeX, maxCharSizeY, 24));

            charSize = baseCharSize * currentZoom;

            // Ensure view offsets are within valid range after zoom/resize
            clampViewOffsets();

            // Set font properties based on updated charSize. Using 'monospace' for consistent ASCII alignment.
            ctx.font = `${charSize}px 'monospace'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = currentCol;

            drawMap();
            updateRulers();
        }

        /**
         * Clamps view offsets to prevent panning beyond map boundaries.
         */
        function clampViewOffsets() {
            const maxOffsetX = (mapWidth * charSize) - canvas.width;
            const maxOffsetY = (mapHeight * charSize) - canvas.height;

            viewOffsetX = Math.max(0, Math.min(viewOffsetX, maxOffsetX > 0 ? maxOffsetX : 0));
            viewOffsetY = Math.max(0, Math.min(viewOffsetY, maxOffsetY > 0 ? maxOffsetY : 0));
        }

        /**
         * Draws the entire map data onto the canvas, respecting current pan offset and zoom.
         */
        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate visible grid range
            const startCol = Math.floor(viewOffsetX / charSize);
            const endCol = Math.min(mapWidth, Math.ceil((viewOffsetX + canvas.width) / charSize) + 1); // +1 for partial visibility
            const startRow = Math.floor(viewOffsetY / charSize);
            const endRow = Math.min(mapHeight, Math.ceil((viewOffsetY + canvas.height) / charSize) + 1); // +1 for partial visibility


            for (let y = startRow; y < endRow; y++) {
                for (let x = startCol; x < endCol; x++) {
                    // Calculate position on the canvas relative to the current viewport offset
                    const charX = (x * charSize + charSize / 2) - viewOffsetX;
                    const charY = (y * charSize + charSize / 2) - viewOffsetY;
                    // Only draw if within canvas bounds for performance
                    if (charX >= -charSize && charX < canvas.width + charSize && charY >= -charSize && charY < canvas.height + charSize) {
                         ctx.fillText(mapData[y][x], charX, charY);
                    }
                }
            }
            updateIndicators();
        }

        /**
         * Updates the rulers based on current view offset and character size.
         */
        function updateRulers() {
            rulerX.innerHTML = ''; // Clear existing rulers
            rulerY.innerHTML = '';

            const rulerFontSize = Math.max(8, Math.min(10, charSize / 2)); // Adjust ruler font size based on charSize

            // Horizontal ruler
            const startXIndex = Math.floor(viewOffsetX / charSize);
            const endXIndex = Math.ceil((viewOffsetX + canvas.width) / charSize);
            for (let i = startXIndex; i < endXIndex; i++) {
                if (i >= 0 && i < mapWidth) {
                    const span = document.createElement('span');
                    span.textContent = i % 10;
                    span.style.left = `${(i * charSize - viewOffsetX)}px`;
                    span.style.width = `${charSize}px`;
                    span.style.fontSize = `${rulerFontSize}px`;
                    rulerX.appendChild(span);
                }
            }
            rulerX.style.width = `${canvas.width}px`;

            // Vertical ruler
            const startYIndex = Math.floor(viewOffsetY / charSize);
            const endYIndex = Math.ceil((viewOffsetY + canvas.height) / charSize);
            for (let i = startYIndex; i < endYIndex; i++) {
                if (i >= 0 && i < mapHeight) {
                    const span = document.createElement('span');
                    span.textContent = i % 10;
                    span.style.top = `${(i * charSize - viewOffsetY)}px`;
                    span.style.height = `${charSize}px`;
                    span.style.fontSize = `${rulerFontSize}px`;
                    rulerY.appendChild(span);
                }
            }
            rulerY.style.height = `${canvas.height}px`;
        }

        /**
         * Updates visibility of side indicators based on pan position.
         */
        function updateIndicators() {
            indicatorTop.classList.toggle('visible', viewOffsetY > 0);
            indicatorBottom.classList.toggle('visible', viewOffsetY + canvas.height < mapHeight * charSize);
            indicatorLeft.classList.toggle('visible', viewOffsetX > 0);
            indicatorRight.classList.toggle('visible', viewOffsetX + canvas.width < mapWidth * charSize);
        }

        /**
         * Gets the grid coordinates (column, row) from mouse event coordinates,
         * accounting for current pan offset.
         * @param {MouseEvent|TouchEvent} event The mouse/touch event.
         * @returns {{gridX: number, gridY: number}} The grid coordinates.
         */
        function getGridCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            // Adjust for pan offset to get actual map coordinates
            const gridX = Math.floor((x + viewOffsetX) / charSize);
            const gridY = Math.floor((y + viewOffsetY) / charSize);

            return { gridX, gridY };
        }

        /**
         * Implements the flood fill algorithm.
         * @param {number} startX Starting X coordinate.
         * @param {number} startY Starting Y coordinate.
         * @param {string} newChar The character to fill with.
         * @param {string} targetChar The original character to replace.
         */
        function floodFill(startX, startY, newChar, targetChar) {
            // Check boundaries and if the current cell is the target character
            if (startX < 0 || startX >= mapWidth || startY < 0 || startY >= mapHeight || mapData[startY][startX] !== targetChar) {
                return;
            }
            // Avoid filling with the same character
            if (newChar === targetChar) return;

            const queue = [{ x: startX, y: startY }];
            while (queue.length > 0) {
                const { x, y } = queue.shift();

                if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight || mapData[y][x] !== targetChar) {
                    continue; // Skip if out of bounds or not target character
                }

                mapData[y][x] = newChar; // Fill the cell

                // Add neighbors to the queue
                queue.push({ x: x, y: y + 1 });
                queue.push({ x: x, y: y - 1 });
                queue.push({ x: x + 1, y: y });
                queue.push({ x: x - 1, y: y });
            }
        }

        /**
         * Draws the box outline using box drawing characters onto a target map.
         * @param {Array<Array<string>>} targetMap The map array to draw on (either mapData or tempMapData).
         * @param {number} minX Top-left X coordinate of the box.
         * @param {number} minY Top-left Y coordinate of the box.
         * @param {number} maxX Bottom-right X coordinate of the box.
         * @param {number} maxY Bottom-right Y coordinate of the box.
         */
        function drawBoxOutline(targetMap, minX, minY, maxX, maxY) {
            const topLeft = '┌';
            const topRight = '┐';
            const bottomLeft = '└';
            const bottomRight = '┘';
            const horizontal = '─';
            const vertical = '│';

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    // Check boundaries first to avoid errors
                    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) continue;

                    if (x === minX && y === minY) { // Top-left corner
                        targetMap[y][x] = topLeft;
                    } else if (x === maxX && y === minY) { // Top-right corner
                        targetMap[y][x] = topRight;
                    } else if (x === minX && y === maxY) { // Bottom-left corner
                        targetMap[y][x] = bottomLeft;
                    } else if (x === maxX && y === maxY) { // Bottom-right corner
                        targetMap[y][x] = bottomRight;
                    } else if (y === minY || y === maxY) { // Horizontal walls (top/bottom)
                        targetMap[y][x] = horizontal;
                    } else if (x === minX || x === maxX) { // Vertical walls (left/right)
                        targetMap[y][x] = vertical;
                    }
                    // If a cell is inside the box but not part of the border, it remains unchanged.
                }
            }
        }

        /**
         * Generates a random dungeon map based on selected style.
         */
        function generateRandomMap() {
            const newMapWidth = parseInt(mapWidthInput.value);
            const newMapHeight = parseInt(mapHeightInput.value);
            const numFeatures = parseInt(roomCountInput.value); // Renamed to numFeatures for clarity across styles
            const mapStyle = mapStyleSelect.value;

            if (!validateMapParameters(newMapWidth, newMapHeight, numFeatures)) {
                return;
            }

            mapWidth = newMapWidth;
            mapHeight = newMapHeight;

            // Reset map and global state
            mapData = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(' ')); // Default to void space
            generatedRooms = []; // Clear rooms on new map creation
            currentZoom = 1.0; // Reset zoom
            viewOffsetX = 0; // Reset pan
            viewOffsetY = 0; // Reset pan

            // Initialize global visited regions at the start of map generation for unique regions
            globalVisitedRegions = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(false));

            switch (mapStyle) {
                case 'town':
                    generateTownMap(numFeatures);
                    break;
                case 'cave':
                    generateCaveMap(numFeatures);
                    break;
                case 'forest':
                    generateForestMap(numFeatures);
                    break;
                default:
                    generateTownMap(numFeatures);
            }

            updateCanvasAndDraw(); // Redraw the new random map
            showMessageBox(`Generated random map (Style: ${mapStyle.charAt(0).toUpperCase() + mapStyle.slice(1)})`);
        }

        /**
         * Carves a connected region of a specific fill character into the map using a drunkard's walk.
         * Ensures distinct regions by preventing starting points near already carved areas.
         * @param {number} startX Candidate start X for the region.
         * @param {number} startY Candidate start Y for the region.
         * @param {string} targetChar The character to replace (e.g., ' ' for cave, '#' for forest).
         * @param {string} fillChar The character to fill with (e.g., '.').
         * @param {Array<Array<boolean>>} globalVisitedMatrix Global visited matrix to track cells from all successfully carved regions.
         * @param {number} minSize Minimum size of the region (in cells).
         * @param {number} maxSize Maximum size of the region (in cells).
         * @param {number} boundaryBuffer Minimum distance from already carved regions.
         * @returns {boolean} True if a region of sufficient size was carved.
         */
        function carveRegion(startX, startY, targetChar, fillChar, globalVisitedMatrix, minSize, maxSize, boundaryBuffer) {
            // Check if the starting point is valid: it must be targetChar, not already visited, and sufficiently far from other regions
            const isTooCloseToExistingRegion = (x, y) => {
                for (let by = y - boundaryBuffer; by <= y + boundaryBuffer; by++) {
                    for (let bx = x - boundaryBuffer; bx <= x + boundaryBuffer; bx++) {
                        if (bx >= 0 && bx < mapWidth && by >= 0 && by < mapHeight && globalVisitedMatrix[by][bx]) {
                            return true; // Too close to an already carved region
                        }
                    }
                }
                return false;
            };

            // Ensure startX, startY are not on the immediate border and are valid
            if (startX < boundaryBuffer || startX >= mapWidth - boundaryBuffer || startY < boundaryBuffer || startY >= mapHeight - boundaryBuffer ||
                mapData[startY][startX] !== targetChar || globalVisitedMatrix[startY][startX] ||
                isTooCloseToExistingRegion(startX, startY)) {
                return false; // Invalid start point
            }

            let currentRegionCells = [];
            let currX = startX;
            let currY = startY;
            // Randomize desired size within the min/max range
            const cellsToCarve = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;

            // Immediately mark the starting cell
            mapData[currY][currX] = fillChar;
            currentRegionCells.push({ x: currX, y: currY });

            const directions = [{dx:0,dy:1}, {dx:0,dy:-1}, {dx:1,dy:0}, {dx:-1,dy:0}]; // Cardinal directions for walk

            // Drunkard's walk: attempt to carve 'cellsToCarve' cells with some randomness
            for (let i = 0; i < cellsToCarve * 5 && currentRegionCells.length < cellsToCarve; i++) { // More attempts than cells for better chance of reaching size
                const { dx, dy } = directions[Math.floor(Math.random() * directions.length)];
                let nextX = currX + dx;
                let nextY = currY + dy;

                // Ensure potential next cell is within bounds (with a buffer) and not part of an already carved *distinct* region
                if (nextX > 0 && nextX < mapWidth - 1 && nextY > 0 && nextY < mapHeight - 1 &&
                    !globalVisitedRegions[nextY][nextX] && // Crucial: avoid merging with distinct regions
                    mapData[nextY][nextX] === targetChar) { // Only carve if it's the target char

                    mapData[nextY][nextX] = fillChar;
                    currentRegionCells.push({ x: nextX, y: nextY });
                    currX = nextX;
                    currY = nextY;
                } else if (mapData[nextY] && mapData[nextY][nextX] === fillChar) {
                    // Allow moving into an already carved part of *this* region
                    currX = nextX;
                    currY = nextY;
                }
            }

            if (currentRegionCells.length >= minSize) {
                // Mark all cells of this successfully carved region in the global visited matrix
                for (const cell of currentRegionCells) {
                    globalVisitedRegions[cell.y][cell.x] = true;
                }
                return true;
            } else {
                // Region was too small or failed to expand, revert changes
                for (const cell of currentRegionCells) {
                    mapData[cell.y][cell.x] = targetChar; // Revert to original character
                }
                return false;
            }
        }


        /**
         * Generates a town-like map with rooms and corridors.
         * @param {number} numRooms The number of rooms to attempt to generate.
         */
        function generateTownMap(numRooms) {
            const MIN_ROOM_SIZE = 5;
            const MAX_ROOM_SIZE = 15;
            const ROOM_ATTEMPTS = numRooms * 5;

            // Step 1: Create rooms
            for (let i = 0; i < ROOM_ATTEMPTS && generatedRooms.length < numRooms; i++) {
                const rw = Math.floor(Math.random() * ((MAX_ROOM_SIZE - MIN_ROOM_SIZE) / 2 + 1)) * 2 + MIN_ROOM_SIZE;
                const rh = Math.floor(Math.random() * ((MAX_ROOM_SIZE - MIN_ROOM_SIZE) / 2 + 1)) * 2 + MIN_ROOM_SIZE;

                const rx = Math.floor(Math.random() * (mapWidth - rw - 1)) + 1;
                const ry = Math.floor(Math.random() * (mapHeight - rh - 1)) + 1;

                const newRoom = { x: rx, y: ry, width: rw, height: rh };

                let overlaps = false;
                for (const existingRoom of generatedRooms) {
                    // Check for overlap with a buffer of 1 cell
                    if (newRoom.x < existingRoom.x + existingRoom.width + 1 &&
                        newRoom.x + newRoom.width + 1 > existingRoom.x &&
                        newRoom.y < existingRoom.y + existingRoom.height + 1 &&
                        newRoom.y + newRoom.height + 1 > existingRoom.y) {
                        overlaps = true;
                        break;
                    }
                }

                if (!overlaps) {
                    // Carve out floor
                    for (let y = newRoom.y + 1; y < newRoom.y + newRoom.height - 1; y++) {
                        for (let x = newRoom.x + 1; x < newRoom.x + newRoom.width - 1; x++) {
                            mapData[y][x] = '.'; // Floor
                        }
                    }
                    // Draw box outline for walls
                    drawBoxOutline(mapData, newRoom.x, newRoom.y, newRoom.x + newRoom.width - 1, newRoom.y + newRoom.height - 1);
                    generatedRooms.push(newRoom);
                }
            }

            // Step 2: Connect rooms with corridors
            // Sort rooms by X coordinate to connect them in a sensible order
            generatedRooms.sort((a, b) => a.x - b.x);
            for (let i = 0; i < generatedRooms.length - 1; i++) {
                const room1 = generatedRooms[i];
                const room2 = generatedRooms[i + 1];

                const center1X = Math.floor(room1.x + room1.width / 2);
                const center1Y = Math.floor(room1.y + room1.height / 2);
                const center2X = Math.floor(room2.x + room2.width / 2);
                const center2Y = Math.floor(room2.y + room2.height / 2);

                // Draw horizontal corridor
                for (let x = Math.min(center1X, center2X); x <= Math.max(center1X, center2X); x++) {
                    if (center1Y >= 0 && center1Y < mapHeight && x >= 0 && x < mapWidth) {
                        if (!['┌', '┐', '└', '┘', '─', '│'].includes(mapData[center1Y][x])) { // Avoid overwriting room corners/walls
                            mapData[center1Y][x] = '.'; // Path
                        }
                    }
                }
                // Draw vertical corridor
                for (let y = Math.min(center1Y, center2Y); y <= Math.max(center1Y, center2Y); y++) {
                    if (y >= 0 && y < mapHeight && center2X >= 0 && center2X < mapWidth) {
                        if (!['┌', '┐', '└', '┘', '─', '│'].includes(mapData[y][center2X])) { // Avoid overwriting room corners/walls
                             mapData[y][center2X] = '.'; // Path
                        }
                    }
                }
            }

            // Step 3: Add doors randomly (no stairs)
            addSpecialItemsRandomly('town');
        }

        /**
         * Generates a cave-like map with multiple disconnected cave systems.
         * @param {number} numCaves The number of distinct cave systems to generate.
         */
        function generateCaveMap(numCaves) {
            // Fill map with ' ' (void/wall) initially
            mapData = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(' '));
            // Re-initialize global visited regions at the start of map generation
            globalVisitedRegions = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(false));

            const minCaveSize = Math.floor(mapWidth * mapHeight * MIN_REGION_SIZE_FACTOR);
            const maxCaveSize = Math.floor(mapWidth * mapHeight * MAX_REGION_SIZE_FACTOR);
            const boundaryBuffer = 3; // Ensure clear separation between caves

            let cavesPlaced = 0;
            let attempts = 0;

            while (cavesPlaced < numCaves && attempts < MAX_CARVE_ATTEMPTS * numCaves) {
                const startX = Math.floor(Math.random() * (mapWidth - 2)) + 1; // Avoid immediate borders
                const startY = Math.floor(Math.random() * (mapHeight - 2)) + 1; // Avoid immediate borders

                // Try to carve a region
                if (carveRegion(startX, startY, ' ', '.', globalVisitedRegions, minCaveSize, maxCaveSize, boundaryBuffer)) {
                    cavesPlaced++;
                }
                attempts++;
            }

            // Ensure the outer border is completely solid ' ' (void)
            for (let y = 0; y < mapHeight; y++) {
                mapData[y][0] = ' ';
                mapData[y][mapWidth - 1] = ' ';
            }
            for (let x = 0; x < mapWidth; x++) {
                mapData[0][x] = ' ';
                mapData[mapHeight - 1][x] = ' ';
            }

            addSpecialItemsRandomly('cave');
            // Do NOT call connectMapRegions here, as caves are meant to be separated
        }

        /**
         * Generates a forest-like map with multiple disconnected clearings.
         * @param {number} numClearings The number of distinct clearings to generate.
         */
        function generateForestMap(numClearings) {
            // Fill map with '#' (trees) initially
            mapData = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill('#'));
            // Re-initialize global visited regions at the start of map generation
            globalVisitedRegions = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(false));

            const minClearingSize = Math.floor(mapWidth * mapHeight * MIN_REGION_SIZE_FACTOR);
            const maxClearingSize = Math.floor(mapWidth * mapHeight * MAX_REGION_SIZE_FACTOR);
            const boundaryBuffer = 3; // Ensure clear separation between clearings

            let clearingsPlaced = 0;
            let attempts = 0;

            while (clearingsPlaced < numClearings && attempts < MAX_CARVE_ATTEMPTS * numClearings) {
                const startX = Math.floor(Math.random() * (mapWidth - 2)) + 1; // Avoid immediate borders
                const startY = Math.floor(Math.random() * (mapHeight - 2)) + 1; // Avoid immediate borders

                // Try to carve a region
                if (carveRegion(startX, startY, '#', '.', globalVisitedRegions, minClearingSize, maxClearingSize, boundaryBuffer)) {
                    clearingsPlaced++;
                }
                attempts++;
            }

            // Ensure the outer border is completely solid '#' (trees)
            for (let y = 0; y < mapHeight; y++) {
                mapData[y][0] = '#';
                mapData[y][mapWidth - 1] = '#';
            }
            for (let x = 0; x < mapWidth; x++) {
                mapData[0][x] = '#';
                mapData[mapHeight - 1][x] = '#';
            }

            addSpecialItemsRandomly('forest');
            // Do NOT call connectMapRegions here, as clearings are meant to be separated
        }

        /**
         * Adds doors randomly to the map based on map style.
         * Places doors on walls adjacent to floor. No stairs added.
         */
        function addSpecialItemsRandomly(style) {
            const MAX_DOORS = Math.min(Math.floor(mapWidth * mapHeight / 200), 5); // Max 5 doors or 0.5% of map
            let doorsPlaced = 0;
            let stairsPlaced = 0;
            const MAX_STAIRS = Math.min(Math.floor(mapWidth * mapHeight / 300), 3); // Max 3 stairs or 0.33% of map

            for (let i = 0; i < MAX_DOORS * 5; i++) { // Attempt more times to place doors
                const rx = Math.floor(Math.random() * mapWidth);
                const ry = Math.floor(Math.random() * mapHeight);

                // Place doors
                if (doorsPlaced < MAX_DOORS && rx >=0 && rx < mapWidth && ry >=0 && ry < mapHeight) {
                    const currentCell = mapData[ry][rx];
                    if (style === 'town' && ['─', '│'].includes(currentCell)) {
                        const isHorizontalDoorSpot = (rx > 0 && mapData[ry][rx-1] === '.') && (rx < mapWidth - 1 && mapData[ry][rx+1] === '.');
                        const isVerticalDoorSpot = (ry > 0 && mapData[ry-1][rx] === '.') && (ry < mapHeight - 1 && mapData[ry+1][rx] === '.');

                        if (isHorizontalDoorSpot || isVerticalDoorSpot) {
                            mapData[ry][rx] = '+';
                            doorsPlaced++;
                        }
                    } else if (style === 'cave' || style === 'forest') {
                        // For caves/forests, doors might just appear on walls next to floor.
                        // Simplified: find an isolated ' ' (wall/void) cell surrounded by '.' (floor)
                        const neighbors = [
                            {x: rx - 1, y: ry}, {x: rx + 1, y: ry},
                            {x: rx, y: ry - 1}, {x: rx, y: ry + 1}
                        ];
                        let floorNeighbors = 0;
                        for (const n of neighbors) {
                            if (n.x >= 0 && n.x < mapWidth && n.y >= 0 && n.y < mapHeight && mapData[n.y][n.x] === '.') {
                                floorNeighbors++;
                            }
                        }
                        if (currentCell === ' ' && floorNeighbors >= 2) { // At least two floor neighbors to be a door candidate
                            mapData[ry][rx] = '+';
                            doorsPlaced++;
                        }
                    }
                }
            }

            // Add stairs for cave/forest maps
            if (style === 'cave' || style === 'forest') {
                for (let i = 0; i < MAX_STAIRS * 5; i++) { // Attempt more times to place stairs
                    const rx = Math.floor(Math.random() * mapWidth);
                    const ry = Math.floor(Math.random() * mapHeight);

                    if (stairsPlaced < MAX_STAIRS && rx >=0 && rx < mapWidth && ry >=0 && ry < mapHeight) {
                        const currentCell = mapData[ry][rx];
                        if (currentCell === '.') { // Only place stairs on floor
                            mapData[ry][rx] = (Math.random() < 0.5) ? '>' : '<'; // Randomly '>' or '<'
                            stairsPlaced++;
                        }
                    }
                }
            }
        }


        // --- Event Handlers ---

        /**
         * Handles mouse/touch down event on canvas.
         * @param {MouseEvent|TouchEvent} event
         */
        function handleCanvasMouseDown(event) {
            event.preventDefault(); // Prevent default touch behavior (scrolling, zooming)
            isDrawing = true; // For drawing tools
            isPanning = false; // Assume not panning initially

            const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);

            lastPanMouseX = clientX;
            lastPanMouseY = clientY;

            if (currentTool === 'move') {
                isPanning = true;
                canvas.style.cursor = 'grab'; // Change cursor for move tool
            } else {
                canvas.style.cursor = 'crosshair'; // Default cursor for drawing tools
                const { gridX, gridY } = getGridCoordinates(event);
                startGridX = gridX;
                startGridY = gridY;

                if (currentTool === 'paint') {
                    if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
                        mapData[gridY][gridX] = drawChar;
                        drawMap();
                    }
                } else if (currentTool === 'door') {
                    if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
                        mapData[gridY][gridX] = '+'; // Door character
                        drawMap();
                    }
                } else if (currentTool === 'stairs') { // Stairs tool still available for manual drawing
                    if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
                        // Use current drawChar, default to '>' if not specified for stairs
                        mapData[gridY][gridX] = (Math.random() < 0.5) ? '>' : '<'; // Randomly '>' or '<'
                        drawMap();
                    }
                } else if (currentTool === 'fill') {
                    if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight) {
                        const targetChar = mapData[gridY][gridX];
                        if (targetChar !== drawChar) { // Only fill if target is different
                            floodFill(gridX, gridY, drawChar, targetChar);
                            drawMap();
                        }
                    }
                }
            }
        }

        /**
         * Handles mouse/touch move event on canvas.
         * @param {MouseEvent|TouchEvent} event
         */
        function handleCanvasMouseMove(event) {
            event.preventDefault(); // Prevent default touch behavior
            const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);

            const { gridX, gridY } = getGridCoordinates(event);
            coordinatesDisplay.textContent = `Mouse: (X: ${gridX}, Y: ${gridY})`;

            if (isPanning && currentTool === 'move') {
                const dx = clientX - lastPanMouseX;
                const dy = clientY - lastPanMouseY;

                viewOffsetX -= dx;
                viewOffsetY -= dy;

                clampViewOffsets(); // Ensure offsets are valid after panning

                lastPanMouseX = clientX;
                lastPanMouseY = clientY;

                drawMap();
                updateRulers();
            } else if (isDrawing && currentTool === 'paint') {
                // Draw if within bounds and different character
                if (gridX >= 0 && gridX < mapWidth && gridY >= 0 && gridY < mapHeight && mapData[gridY][gridX] !== drawChar) {
                    mapData[gridY][gridX] = drawChar;
                    drawMap();
                }
            } else if (isDrawing && currentTool === 'box') {
                // Live preview for box tool
                const tempMapData = JSON.parse(JSON.stringify(mapData)); // Create a deep copy
                const minX = Math.min(startGridX, gridX);
                const maxX = Math.max(startGridX, gridX);
                const minY = Math.min(startGridY, gridY);
                const maxY = Math.max(startGridY, gridY);

                // Draw a simple box outline for preview
                drawBoxOutline(tempMapData, minX, minY, maxX, maxY);


                // Re-draw with temporary data
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const startCol = Math.floor(viewOffsetX / charSize);
                const endCol = Math.min(mapWidth, Math.ceil((viewOffsetX + canvas.width) / charSize) + 1);
                const startRow = Math.floor(viewOffsetY / charSize);
                const endRow = Math.min(mapHeight, Math.ceil((viewOffsetY + canvas.height) / charSize) + 1);

                for (let y = startRow; y < endRow; y++) {
                    for (let x = startCol; x < endCol; x++) {
                        const charX = (x * charSize + charSize / 2) - viewOffsetX;
                        const charY = (y * charSize + charSize / 2) - viewOffsetY;
                        if (charX >= -charSize && charX < canvas.width + charSize && charY >= -charSize && charY < canvas.height + charSize) {
                            ctx.fillText(tempMapData[y][x], charX, charY);
                        }
                    }
                }
            }
        }

        /**
         * Handles mouse/touch up event on canvas.
         * @param {MouseEvent|TouchEvent} event
         */
        function handleCanvasMouseUp(event) {
            event.preventDefault(); // Prevent default touch behavior
            if (!isDrawing) return; // Only process if drawing started
            isDrawing = false;
            isPanning = false;
            canvas.style.cursor = (currentTool === 'move') ? 'grab' : 'crosshair'; // Reset cursor

            const { gridX, gridY } = getGridCoordinates(event);

            const minX = Math.min(startGridX, gridX);
            const maxX = Math.max(startGridX, gridX);
            const minY = Math.min(startGridY, gridY);
            const maxY = Math.max(startGridY, gridY);

            // Ensure coordinates are within map bounds
            const finalMinX = Math.max(0, minX);
            const finalMaxX = Math.min(mapWidth - 1, maxX);
            const finalMinY = Math.max(0, minY);
            const finalMaxY = Math.min(mapHeight - 1, maxY);

            if (currentTool === 'box') {
                drawBoxOutline(mapData, finalMinX, finalMinY, finalMaxX, finalMaxY);
            }
            drawMap(); // Redraw the final map state
        }

        /**
         * Handles mouse leave event on canvas to stop drawing/panning.
         * @param {MouseEvent} event
         */
        function handleCanvasMouseLeave(event) {
            if (isDrawing || isPanning) {
                // If the mouse leaves while drawing/panning, simulate mouse up
                handleCanvasMouseUp(event);
            }
            coordinatesDisplay.textContent = `Mouse: (X: -, Y: -)`; // Clear coordinates
        }

        // --- Event Listeners ---

        // Initialize map when the window loads
        window.onload = function() {
            initializeMap();
            // Add a resize listener to handle responsiveness
            window.addEventListener('resize', () => {
                updateCanvasAndDraw();
            });
            // Initial update of the room count label based on default style
            updateRoomCountLabel();
        };

        // Sidebar toggle functionality
        toggleSidebarBtn.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            toggleSidebarBtn.classList.toggle('collapsed');
            if (sidebar.classList.contains('collapsed')) {
                toggleIcon.textContent = '▶';
            } else {
                toggleIcon.textContent = '◀';
            }
            // Trigger a canvas redraw after sidebar transition completes
            // This ensures the canvas resizes correctly after the layout change
            setTimeout(updateCanvasAndDraw, 300); // Match CSS transition duration
        });


        // Create Map button click
        createMapBtn.addEventListener('click', initializeMap);

        // Random Map button click
        randomMapBtn.addEventListener('click', generateRandomMap);

        // Update room count label when map style changes
        mapStyleSelect.addEventListener('change', updateRoomCountLabel);

        /**
         * Updates the text content of the roomCountLabel based on the selected map style.
         */
        function updateRoomCountLabel() {
            const selectedStyle = mapStyleSelect.value;
            switch (selectedStyle) {
                case 'town':
                    roomCountLabel.textContent = 'Rooms:';
                    break;
                case 'cave':
                    roomCountLabel.textContent = 'Caves:';
                    break;
                case 'forest':
                    roomCountLabel.textContent = 'Clearings:';
                    break;
                default:
                    roomCountLabel.textContent = 'Rooms:';
            }
        }


        // Tool selection
        toolRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentTool = event.target.value;
                // Update default char based on tool or reset if not a special tool
                if (currentTool === 'door') {
                    drawCharInput.value = '+';
                } else if (currentTool === 'stairs') {
                    // When stairs tool is selected, if custom char is not '>' or '<', default to '>'
                    if (drawCharInput.value !== '>' && drawCharInput.value !== '<') {
                        drawCharInput.value = '>';
                    }
                } else if (currentTool === 'move') {
                    canvas.style.cursor = 'grab'; // Set cursor for move tool
                } else { // paint, fill, box
                    canvas.style.cursor = 'crosshair'; // Reset cursor for drawing tools
                    // When switching to paint/fill/box, set drawChar to the currently selected quick char, or '#'
                    const selectedQuickChar = document.querySelector('select[name="quickCharGroup"] option:checked')?.value;
                    drawCharInput.value = selectedQuickChar || '#';
                }
                drawChar = drawCharInput.value; // Update drawChar from input field
            });
        });

        // Drawing character input change (for custom char)
        drawCharInput.addEventListener('input', (event) => {
            drawChar = event.target.value.substring(0, 1) || ' '; // Default to space if empty
            drawCharInput.value = drawChar; // Force single char in input
        });

        // Quick character group select change
        quickCharGroupSelects.forEach(select => {
            select.addEventListener('change', (event) => {
                drawChar = event.target.value;
                drawCharInput.value = drawChar === ' ' ? '' : drawChar; // Set input, clear for space
                // Auto-select paint tool when a char is selected from a dropdown, if not move/fill/door/stairs/box
                if (currentTool === 'move' || currentTool === 'fill' || currentTool === 'door' || currentTool === 'stairs' || currentTool === 'box') {
                    // Do nothing, let the current specialized tool remain active
                } else {
                    document.getElementById('toolPaint').checked = true;
                    currentTool = 'paint';
                    canvas.style.cursor = 'crosshair';
                }
            });
        });


        // Canvas mouse/touch events
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);

        // Touch events for mobile responsiveness
        canvas.addEventListener('touchstart', handleCanvasMouseDown);
        canvas.addEventListener('touchmove', handleCanvasMouseMove);
        canvas.addEventListener('touchend', handleCanvasMouseUp);
        canvas.addEventListener('touchcancel', handleCanvasMouseUp); // Consider touchcancel as mouseup

        // Clear Map button click
        clearMapBtn.addEventListener('click', () => {
            initializeMap(); // Re-initialize the map to clear it
            showMessageBox("Map cleared!");
        });

        // Export Map button click
        exportMapBtn.addEventListener('click', () => {
            const mapText = mapData.map(row => row.join('')).join('\n');
            const blob = new Blob([mapText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tilemap.txt';
            document.body.appendChild(a); // Append to body to make it clickable
            a.click(); // Programmatically click the link
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Release the object URL
            showMessageBox("Map exported successfully as tilemap.txt!");
        });

        // Close message box button
        closeMessageBoxBtn.addEventListener('click', hideMessageBox);

        // Zoom button event listeners
        zoomInBtn.addEventListener('click', () => {
            currentZoom = Math.min(MAX_ZOOM, currentZoom + ZOOM_STEP);
            updateCanvasAndDraw();
        });

        zoomOutBtn.addEventListener('click', () => {
            currentZoom = Math.max(MIN_ZOOM, currentZoom - ZOOM_STEP);
            updateCanvasAndDraw();
        });

        // Mouse Wheel Zoom
        canvas.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling

            const oldZoom = currentZoom;
            if (event.deltaY < 0) { // Zoom in
                currentZoom = Math.min(MAX_ZOOM, currentZoom + ZOOM_WHEEL_STEP);
            } else { // Zoom out
                currentZoom = Math.max(MIN_ZOOM, currentZoom - ZOOM_WHEEL_STEP);
            }

            // Adjust view offset to zoom towards the mouse pointer
            const mouseX_canvas = event.clientX - canvas.getBoundingClientRect().left;
            const mouseY_canvas = event.clientY - canvas.getBoundingClientRect().top;

            const oldMapX_pixel = viewOffsetX + mouseX_canvas;
            const oldMapY_pixel = viewOffsetY + mouseY_canvas;


            viewOffsetX = (oldMapX_pixel * (currentZoom / oldZoom)) - mouseX_canvas;
            viewOffsetY = (oldMapY_pixel * (currentZoom / oldZoom)) - mouseY_canvas;

            updateCanvasAndDraw();
        }, { passive: false }); // Use passive: false to allow preventDefault

        // --- Load Map Button and File Input Logic ---
        loadMapBtn.addEventListener('click', () => {
            loadFileInput.click(); // Programmatically click the hidden file input
        });

        loadFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                const lines = content.split(/\r?\n/); // Split by newline, handle both Windows/Unix

                let loadedHeight = lines.length;
                let loadedWidth = 0;
                // Determine the maximum width
                for (const line of lines) {
                    if (line.length > loadedWidth) {
                        loadedWidth = line.length;
                    }
                }

                // Validate loaded map dimensions against requirements
                if (!validateMapParameters(loadedWidth, loadedHeight, 2)) { // Rooms count is arbitrary for loaded map
                    showMessageBox(`Loaded map dimensions (${loadedWidth}x${loadedHeight}) are outside the allowed range (20-65536). Map not loaded.`);
                    return;
                }

                // Update input fields and global variables
                mapWidthInput.value = loadedWidth;
                mapHeightInput.value = loadedHeight;
                mapWidth = loadedWidth;
                mapHeight = loadedHeight;

                // Reinitialize mapData with loaded content, padding or truncating lines as needed
                mapData = [];
                for (let i = 0; i < loadedHeight; i++) {
                    let line = lines[i] || ''; // Handle potentially empty lines
                    if (line.length < mapWidth) {
                        line = line.padEnd(mapWidth, ' '); // Pad with spaces
                    } else if (line.length > mapWidth) {
                        line = line.substring(0, mapWidth); // Truncate
                    }
                    mapData.push(line.split(''));
                }
                
                generatedRooms = []; // Clear generated rooms as this is a loaded map
                currentZoom = 1.0; // Reset zoom for loaded map
                viewOffsetX = 0; // Reset pan
                viewOffsetY = 0; // Reset pan

                updateCanvasAndDraw();
                showMessageBox(`Map "${file.name}" loaded successfully! Dimensions: ${loadedWidth}x${loadedHeight}`);
            };

            reader.onerror = (e) => {
                showMessageBox(`Error reading file: ${e.target.error.name}`);
            };

            reader.readAsText(file);
        });

    </script>
</body>
</html>
